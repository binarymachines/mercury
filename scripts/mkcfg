#!/usr/bin/env python

'''
Usage:
  mkcfg --list
  mkcfg <target>

Options:
  -l --list       show the available configuration targets
'''

import os, sys
from os import system, name
from contextlib import contextmanager
import copy
import itertools
from enum import Enum
from cmd import Cmd
import yaml
from snap import common
from snap import cli_tools as cli
from mercury import configtemplates as templates
from mercury import metaobjects as meta
from mercury.uisequences import *
import docopt
from docopt import docopt as docopt_func
from docopt import DocoptExit
import jinja2


BANNER = '''
___________________________________________________________________________
|::
|:: mkcfg interactive configfile generator
|:: issue "mkcfg <target>" to create a config file for a target utility.
|::
|::
|:: available config targets:
|:'''

BANNER_CLOSE = '|__________________________________________________________________________\n'


class Whitespace(Enum):
  space = ' '
  tab = '\t'

def tab(num_tabs):
  return ''.join(itertools.repeat('\t', num_tabs))
  
def space(num_spaces):
  return ''.join(itertools.repeat(' ', num_spaces))

def indent(num_indents, whitespace_type):
  return ''.join(itertools.repeat(whitespace_type, num_indents))

def clear(): 
    # for windows 
    if name == 'nt': 
        _ = system('cls') 

    # for mac and linux(here, os.name is 'posix') 
    else: 
        _ = system('clear') 




class UISequenceRunner(object):
  def __init__(self, **kwargs):
    #
    # keyword args:
    # override_create_prompts is an optional dictionary
    # where <key> is the field name of a step in a UI sequence
    # and <value> is a prompt instance from the cli library.
    # This gives users of the UISequenceRunner the option to 
    # override the default Prompt type specified in the ui sequence 
    # dictionary passed to the create() method.
    #
    
    self.create_prompts = kwargs.get('override_create_prompts', {})


  def process_edit_sequence(self, config_object, **sequence):
    
    print(sequence['marquee'])
    context = {}
    for step in sequence['steps']:

      current_target = getattr(config_object, step['field_name'])
      if step.get('sequence'):
        if isinstance(current_target, list):
          # recursively edit embedded lists 
          response = []
          for obj in current_target:
            output = self.process_edit_sequence(obj, **step['sequence'])
            if output is not None:
              response.append(output)

          setattr(config_object, step['field_name'], response)
          continue

        else:
          output = self.process_edit_sequence(**step['sequence'])
          if output:
            setattr(config_object, step['field_name'], output)
          continue
      else:
        if isinstance(current_target, list):
          raise Exception('!!! An edit sequence which handles a list-type attribute must use a child sequence.')   

      context['current_value'] = getattr(config_object, step['field_name'])
      label = step.get('label', step['field_name'])
      context['current_name'] = getattr(config_object, label)      
      prompt = step['prompt_type']
      args = []
      for a in step['prompt_args']:
        args.append(a.format(**context))
      response = prompt(*args).show()
      if response is not None:
        setattr(config_object, step['field_name'], response)
    return config_object


  def process_create_sequence(self, init_context=None, **sequence):
    print(sequence['marquee'])
    context = {}
    if init_context:
      context.update(init_context)
    
    if sequence.get('inputs'):
      context.update(sequence['inputs'])

    for step in sequence['steps']:

      if not step.get('prompt'):
        if not step.get('conditions') and not step.get('sequence'):
          # hard error
          raise Exception('step "%s" in this UI sequence has no prompt and does not branch to a child sequence') 

      # this is an input-dependent branch 
      if step.get('conditions'):
        if not step['conditions'].get(answer):
          raise Exception('a step "%s" in the UI sequence returned an answer "%s" for which there is no condition.' 
                          % (step['field_name'], answer))

        next_sequence = step['conditions'][answer]['sequence']
        outgoing_context = copy.deepcopy(context)
        context[step['field_name']] = self.process_create_sequence(**next_sequence)
         
      # unconditional branch
      elif step.get('sequence'):
        next_sequence = step['sequence']
        outgoing_context = copy.deepcopy(context)
        is_repeating_step =  step.get('repeat', False)

        while True:                 
          sequence_output = self.create(**next_sequence)
          if not sequence_output: 
            break

          if is_repeating_step:
            if not context.get(step['field_name']):
              context[step['field_name']] = []
            context[step['field_name']].append(sequence_output)
          else:
            context[step['field_name']] = sequence_output

          if is_repeating_step:
            repeat_prompt = step.get('repeat_prompt', cli.InputPrompt('create another (Y/n)', 'y'))
            should_repeat = repeat_prompt.show().lower()
            if should_repeat == 'n':
              break
          else:
            break

      else:
        # follow the prompt -- but override the one in the UI sequence if one was passed to us
        # in our constructor
        prompt =  self.create_prompts.get(step['field_name'], step['prompt'])         
        answer = prompt.show()
        if not answer and step['required'] == True:        
          break
        if not answer and hasattr(step, 'default'):        
          answer = step['default']
        else:        
          context[step['field_name']] = answer
  
    return context


  def create(self, **create_sequence):
    context = self.process_create_sequence(**create_sequence)
    output_builder = create_sequence.get('builder_func')
    if output_builder:
      return output_builder(**context)
    return context


  def edit(self, config_object, **edit_sequence):
    self.process_edit_sequence(config_object, **edit_sequence)
    return config_object


def find_global():
  pass

def find_service_object():
  pass

def find_dfproc_processor():
  pass

def find_xfile_map():
  pass

def find_xfile_datasource():
  pass

def find_ngst_datastore_by_name():
  pass

def find_ngst_target_by_name():
  pass

def find_cyclops_trigger_by_name():
  pass

def find_j2sqlgen_target_by_name():
  pass

def find_j2sqlgen_default_by_name():
  pass

def find_pgexec_target_by_name():
  pass

def find_profiler():
  pass

def find_profilr_dataset_by_name():
  pass

def find_quasr_template():
  pass

def find_quasr_job():
  pass


def create_xfile_globals(live_config, target_package):
  # this will return a dictionary containing all global parameters for an xfile project
  result =  UISequenceRunner().create(**xfile_globals_create_sequence)

  # return all Parameter specs
  for key, value in result.items():
    yield meta.Parameter(name=key, value=value)


def create_service_object(live_config, target_package):
  data = UISequenceRunner().create(**service_object_create_sequence)
  if data:
    so_spec = meta.ServiceObjectSpec(data['alias'], data['class'])
    add_params = cli.InputPrompt('Add one or more init params (Y/n)?', 'y').show()
    if add_params.lower() == 'y':
      while True:
        param_data = UISequenceRunner().create(**service_object_param_sequence)
        if param_data:
          so_spec.add_init_param(param_data['name'], param_data.get('value', ''))
          answer = cli.InputPrompt('add another parameter (Y/n)?', 'y').show()
          should_continue = answer.lower()
          if should_continue != 'y':
              break
        else:
          break
    yield so_spec

  return None

  
def create_dfproc_globals(live_config, target_package):
  pass

def create_dfproc_processor(live_config, target_package):
  pass


def create_xfile_datasource(live_config, target_package):
  data = UISequenceRunner().create(**xfile_datasource_create_sequence)
  if data:
    yield meta.DatasourceSpec(data['alias'], data['class'])
  return None
  

def create_xfile_map(live_config, target_package):

  if not live_config.get('sources'):
    print('!!! No datasources registered. Please create a datasource first.')
    return None

  # look up existing datasources in the live configuration
  datasource_select_menudata = []
  for datasource in live_config['sources']:
    datasource_select_menudata.append({'label': datasource.name, 'value': datasource.name})

  # use this generated menu prompt in the uisequence step whose field_name is "lookup_source"
  prompts = {
    'lookup_source': cli.MenuPrompt('lookup datasource', datasource_select_menudata)
  }

  mapspec = UISequenceRunner(override_create_prompts=prompts).create(**xfile_map_create_sequence)
  while True:
    fieldspec = UISequenceRunner().create(**xfile_field_create_sequence)
    if not fieldspec:
      break
    mapspec.add_field_spec(fieldspec)
    answer = cli.InputPrompt('add another field (Y/n)?').show()
    should_continue = answer.lower()
    if should_continue == 'n':
      break
  
  yield mapspec


def create_ngst_globals(live_config, target_package):
  pass

def create_ngst_target(live_config, target_package):
  pass

def create_ngst_datastore(live_config, target_package):
  pass

def create_cyclops_trigger(live_config, target_package):
  pass

def create_cyclops_globals(live_config, target_package):
  pass

def create_j2sqlgen_globals(live_config, target_package):
  pass

def create_j2sqlgen_default(live_config, target_package):
  pass

def create_j2sqlgen_target(live_config, target_package):
  pass

def create_pgexec_target(live_config, target_package):
  pass

def create_profilr_globals(live_config, target_package):
  pass

def create_profilr_profiler(live_config, target_package):
  pass

def create_profilr_dataset(live_config, target_package):
  pass

def create_quasr_template(live_config, target_package):
  pass


def create_quasr_job(live_config, target_package):
  while True:
    jobspec = UISequenceRunner().create(**quasr_job_create_sequence)
    yield jobspec
    answer = cli.InputPrompt('create another job (Y/n)?').show()
    should_continue = answer.lower()
    if should_continue == 'n':
      break


def create_quasr_globals(live_config, target_package):
  # this will return a dictionary containing all global parameters for a quasr project
  result =  UISequenceRunner().create(**quasr_globals_create_sequence)  
  for key, value in result.items():
    yield meta.Parameter(name=key, value=value)


def edit_globals(config_objects):
  for obj in config_objects:
    UISequenceRunner().process_edit_sequence(obj, **parameter_edit_sequence)
             

def edit_service_object(config_objects):
  for obj in config_objects:
    UISequenceRunner().process_edit_sequence(obj, **service_object_edit_sequence)


def edit_dfproc_processor():
  pass


def edit_xfile_datasource(config_objects):
  for obj in config_objects:
    UISequenceRunner().process_edit_sequence(obj, **xfile_datasource_edit_sequence)


def edit_xfile_map(config_objects):
  for obj in config_objects:
    UISequenceRunner().process_edit_sequence(obj, **xfile_map_edit_sequence)


def edit_ngst_datastore():
  pass

def edit_ngst_target():
  pass

def edit_cyclops_trigger():
  pass

def edit_j2sqlgen_default():
  pass

def edit_j2sqlgen_target():
  pass

def edit_pgexec_target():
  pass

def edit_profiler():
  pass

def edit_profilr_dataset():
  pass

def edit_quasr_template():
  pass

def edit_quasr_job():
  pass

def list_globals(global_settings):
  if not len(global_settings):
    print('No globals registered.')
    return
  
  print('globals:')
  for gs in global_settings:
    print('%s%s: %s' % (tab(1), gs.name, gs.value))
  

def list_service_objects(service_objects):
  if not len(service_objects):
    print('No service objects registered.')
    return

  print('service_objects:')
  for so in service_objects:
    print('%s%s:' % (tab(1), so.alias))
    print('%sclass: %s' % (tab(2), so.classname))
    print('%sinit_params:' % tab(2))
    for p in so.init_params:
      print('%s- name: %s' % (tab(3), p.name))
      print('%s  value: %s' % (tab(3), p.value))


def list_dfproc_processors():
  pass

def list_xfile_datasources(datasources):
  if not len(datasources):
    print("No datasources registered.")
    return
  

def list_xfile_maps(maps):
  if not len(maps):
    print("No maps registered.")
    return

  print('maps:')
  for mapspec in maps:
    print('%s%s:' % (tab(1), mapspec.name))
    for field in mapspec.fields:
      print('%s- %s:' % (tab(2), field.name))
      for param in field.parameters:
        print('%s%s: %s' % (tab(3), param.name, param.value))


def list_ngst_datastores():
  pass

def list_ngst_targets():
  pass

def list_cyclops_triggers():
  pass

def list_j2sqlgen_defaults():
  pass

def list_j2sqlgen_targets():
  pass

def list_pgexec_targets():
  pass

def list_profilers():
  pass

def list_profilr_datasets():
  pass

def list_quasr_templates():
  pass

def list_quasr_jobs():
  pass

def validate_xfile_config(yaml_string, live_config):
  errors = []
  yaml_config = yaml.safe_load(yaml_string)
  print(common.jsonpretty(yaml_config))
  if not 'globals' in yaml_config.keys():
    errors.append('config is missing a "globals" section')

  if not yaml_config['globals']:
    errors.append('"globals" section is empty')
  if not 'service_objects' in yaml_config.keys():
    errors. append('config is missing a "service_objects" section')
  if not 'sources' in yaml_config.keys():
    errors.append('config is missing a "sources" section')
  if not 'maps' in yaml_config.keys():
    errors.append('config is missing a "maps" section')

  if yaml_config['maps']:
    for map_name in yaml_config['maps']:
      if not yaml_config['maps'][map_name].get('lookup_source'):
        errors.append('the map "%s" does not specify a lookup_source')
      source_name = yaml_config['maps'][map_name]['lookup_source']
      if source_name not in yaml_config['sources'].keys():
        errors.append('map "%s" specifies an unregistered lookup_source "%s"' 
                      % (map_name, source_name))

  if len(errors):
    return (False, errors)
  else:
    return (True, [])


targets = {
  'dfproc': {
    'description': 'Create and transform Pandas dataframes',
    'template': templates.DFPROC_TEMPLATE,    
    'config_object_types': [
      {
        'name': 'globals',
        'singular_label': 'globals',
        'plural_label': 'globals',
        'index_attribute': 'name',
        'find_func': find_global,
        'create_func': create_dfproc_globals,
        'update_func': edit_globals,
        'list_func': list_globals
      },
      {
        'name': 'service_objects',
        'singular_label': 'service',
        'plural_label': 'services',
        'index_attribute': 'alias',
        'find_func': find_service_object,
        'create_func': create_service_object,
        'update_func': edit_service_object,
        'list_func': list_service_objects
      },
      {
        'name': 'processors',
        'singular_label': 'processor',
        'plural_label': 'processors',
        'index_attribute': 'name',
        'find_func': find_dfproc_processor,
        'create_func': create_dfproc_processor,
        'update_func': edit_dfproc_processor,
        'list_func': list_dfproc_processors
      }
    ]
  },
  'xfile': {
    'description': 'Read and transform CSV or JSON records',
    'template': templates.XFILE_TEMPLATE,
    'validator_func': validate_xfile_config,
    'config_object_types': [
      {
        'name': 'globals',
        'singular_label': 'globals',
        'plural_label': 'globals',
        'index_attribute': 'name',
        'find_func': find_global,
        'create_func': create_xfile_globals,
        'update_func': edit_globals,
        'list_func': list_globals,
        'unit_size': 3,
        'singleton': True
      },
      {
        'name': 'service_objects',
        'singular_label': 'service',
        'plural_label': 'services',
        'index_attribute': 'alias',
        'find_func': find_service_object,
        'create_func': create_service_object,
        'update_func': edit_service_object,
        'list_func': list_service_objects        
      },
      {
        'name': 'sources', 
        'singular_label': 'datasource',
        'plural_label': 'datasources',
        'index_attribute': 'name',
        'find_func': find_xfile_datasource,
        'create_func': create_xfile_datasource,
        'update_func': edit_xfile_datasource,
        'list_func': list_xfile_datasources
      },
      {
        'name': 'maps',
        'singular_label': 'map',
        'plural_label': 'maps',
        'index_attribute': 'name',
        'find_func': find_xfile_map,
        'create_func': create_xfile_map,
        'update_func': edit_xfile_map,
        'list_func': list_xfile_maps
      } 
    ]
  },
  'ngst': {
    'description': 'Send CSV or JSON records to a designated target',
    'template': templates.NGST_TEMPLATE,
    'config_object_types': [
      {
        'name': 'globals',
        'singular_label': 'global',
        'find_func': find_global,
        'create_func': create_ngst_globals,
        'update_func': edit_globals,
        'list_func': list_globals
      },
      {
        'name': 'service_objects',
        'singular_label': 'service',
        'plural_label': 'services',
        'index_attribute': 'alias',
        'find_func': find_service_object,
        'create_func': create_service_object,
        'update_func': edit_service_object,
        'list_func': list_service_objects        
      },
      {
        'name': 'datastores',
        'singular_label': 'ngst datastore',
        'find_func': find_ngst_datastore_by_name,
        'create_func': create_ngst_datastore,
        'update_func': edit_ngst_datastore,
        'list_func': list_ngst_datastores
      },
      {
        'name': 'ingest_targets',
        'singular_label': 'ingest target',
        'find_func': find_ngst_target_by_name,
        'create_func': create_ngst_target,
        'update_func': edit_ngst_target,
        'list_func': list_ngst_targets
      }
    ]
  },
  'cyclops': {
    'description': 'Run custom code in response to filesystem events',
    'template': templates.CYCLOPS_TEMPLATE,
    'config_object_types': [
      {
        'name': 'globals',
        'singular_label': 'globals',
        'plural_label': 'globals',
        'index_attribute': 'name',
        'find_func': find_global,
        'create_func': create_cyclops_globals,
        'update_func': edit_globals,
        'list_func': list_globals
      },
      {
        'name': 'service_objects',
        'singular_label': 'service',
        'plural_label': 'services',
        'index_attribute': 'alias',
        'find_func': find_service_object,
        'create_func': create_service_object,
        'update_func': edit_service_object,
        'list_func': list_service_objects        
      },
      {
        'name': 'triggers',
        'singular_label': 'filesystem event trigger',
        'find_func': find_cyclops_trigger_by_name,
        'create_func': create_cyclops_trigger,
        'update_func': edit_cyclops_trigger,
        'list_func': list_cyclops_triggers
      }
    ]
  },
  'j2sqlgen': {
    'description': 'Generate CREATE TABLE sql statements from JSON metadata',
    'template': templates.J2SQLGEN_TEMPLATE,
    'config_object_types': [
      {
        'name': 'globals',
        'singular_label': 'globals',
        'plural_label': 'globals',
        'index_attribute': 'name',
        'find_func': find_global,
        'create_func': create_j2sqlgen_globals,
        'update_func': edit_globals,
        'list_func': list_globals
      },
      {
        'name': 'defaults',
        'singular_label': 'SQL generation default',
        'find_func': find_j2sqlgen_default_by_name,
        'create_func': create_j2sqlgen_default,
        'update_func': edit_j2sqlgen_default,
        'list_func': list_j2sqlgen_defaults
      },
      {
        'name': 'tables',
        'singular_label': 'j2sql target table',
        'find_func': find_j2sqlgen_target_by_name,
        'create_func': create_j2sqlgen_target,
        'update_func': edit_j2sqlgen_target,
        'list_func': list_j2sqlgen_targets
      }
    ]
  },
  'pgexec': {
    'description': 'Execute SQL commands against a PostgreSQL database',
    'template': templates.PGEXEC_TEMPLATE,
    'config_object_types': [
        {
          'name': 'targets',
          'singular_label': 'target',
          'find_func': find_pgexec_target_by_name,
          'create_func': create_pgexec_target,
          'update_func': edit_pgexec_target,
          'list_func': list_pgexec_targets
        },
      ]
  },
  'pgmeta': {
    'description': 'Extract table metadata as JSON from a PostgreSQL database',
    'template': templates.PGMETA_TEMPLATE,
    'config_object_types': [
        {
          'name': 'targets',
          'singular_label': 'target',
          'find_func': find_pgexec_target_by_name, # pgmeta and pgexec use the same target
          'create_func': create_pgexec_target,
          'update_func': edit_pgexec_target,
          'list_func': list_pgexec_targets
        }
      ]
  },
  'profilr': {
    'description': 'Run custom data profiling logic against a file-based dataset',
    'template': templates.PROFILR_TEMPLATE,
    'config_object_types': [
        {
        'name': 'globals',
        'singular_label': 'global',
        'find_func': find_global,
        'create_func': create_profilr_globals,
        'update_func': edit_globals,
        'list_func': list_globals
      },
      {
        'name': 'service_objects',
        'singular_label': 'service object',
        'index_attribute': 'alias',
        'find_func': find_service_object,
        'create_func': create_service_object,
        'update_func': edit_service_object,
        'list_func': list_service_objects
      },
      {
        'name': 'profilers',
        'singular_label': 'profiler',
        'index_attribute': 'name',
        'find_func': find_profiler,
        'create_func': create_profilr_profiler,
        'update_func': edit_profiler,
        'list_func': list_profilers
      },
      {
        'name': 'datasets',
        'singular_label': 'profilr dataset',
        'find_func': find_profilr_dataset_by_name,
        'create_func': create_profilr_dataset,
        'update_func': edit_profilr_dataset,
        'list_func': list_profilr_datasets
      }
    ]
  },
  'quasr': {
    'description': 'Run custom QA/profiling code against a relational dataset',
    'template': templates.QUASR_TEMPLATE,
    'config_object_types': [
      {
        'name': 'globals',
        'singular_label': 'globals',
        'plural_label': 'globals',
        'index_attribute': 'name',
        'find_func': find_global,
        'create_func': create_quasr_globals,
        'update_func': edit_globals,
        'list_func': list_globals,
        'unit_size': 4,
        'singleton': True
      },
      {
          'name': 'service_objects',
          'singular_label': 'service',
          'index_attribute': 'alias',
          'find_func': find_service_object,
          'create_func': create_service_object,
          'update_func': edit_service_object,
          'list_func': list_service_objects
      },
      {
          'name': 'templates',
          'singular_label': 'template',
          'index_attribute': 'name',
          'find_func': find_quasr_template,
          'create_func': create_quasr_template,
          'update_func': edit_quasr_template,
          'list_func': list_quasr_templates
      },
      {
          'name': 'jobs',
          'singular_label': 'job',
          'plural_label': 'jobs',
          'index_attribute': 'name',
          'find_func': find_quasr_job,
          'create_func': create_quasr_job,
          'update_func': edit_quasr_job,
          'list_func': list_quasr_jobs
      }
    ]
  }
}


def docopt_cmd(func):
    """
    This decorator is used to simplify the try/except block and pass the result
    of the docopt parsing to the called action.
    """
    def fn(self, arg):
        try:
            opt = docopt_func(fn.__doc__, arg)
            #opt = docopt_func(usage_string, arg)

        except DocoptExit as e:
            # The DocoptExit is thrown when the args do not match.
            # We print a message to the user and the usage block.

            print('\nPlease specify one or more valid command parameters.')
            print(e)
            return

        except SystemExit:
            # The SystemExit exception prints the usage for --help
            # We do not need to do the print here.
            return

        return func(self, opt)

    fn.__name__ = func.__name__
    fn.__doc__ = func.__doc__
    fn.__dict__.update(func.__dict__)
    return fn


def docstring(docstr, sep="\n"):
    """
    Decorator: Append to a function's docstring.
    """
    def _decorator(func):
        if func.__doc__ == None:
            func.__doc__ = docstr
        else:
            func.__doc__ = sep.join([func.__doc__, docstr])
        return func
    return _decorator


class ConfigCLI(Cmd):
    def __init__(self,
                 name,
                 target_name,
                 target_package,
                 **kwargs):

        Cmd.__init__(self)
        self.name = name
        self.prompt = '__%s [%s]> ' % (self.name, target_name)
        self.target_package = target_package
        self.configuration = {}
        #self.replay_stack = Stack()


    #def build_project(self, config):
    #  return {}

    def generate_yaml_config(self):
      #print(common.jsonpretty(self.configuration))
      config_template = self.target_package['template']
      j2template = jinja2.Environment(loader=jinja2.BaseLoader).from_string(config_template)
      yaml_conf = j2template.render(project=self.configuration)
      return yaml_conf
      

    def find_config_package_by_plural_label(self, label):
      for config_object_type in self.target_package['config_object_types']:
        if config_object_type['plural_label'] == label:
          return config_object_type


    def find_config_package_by_singular_label(self, label):
      for config_object_type in self.target_package['config_object_types']:
        if config_object_type['singular_label'] == label:
          return config_object_type
      

    def config_object_singular_labels(self):
      return [conftype['singular_label'] for conftype in self.target_package['config_object_types']]


    def config_object_plural_labels(self):
      return [conftype['plural_label'] for conftype in self.target_package['config_object_types']]


    def usage_string_for_new(self):
      template = '''Usage:
          new ({options})
      '''
      return template.format(options=' | '.join(self.config_object_singular_labels()))
    

    def usage_string_for_edit(self):
      return self.usage_string_for_new()


    def usage_string_for_find(self):
      template = '''Usage:
          find ({options})
      '''      
      return template.format(options=' | '.join(self.config_object_singular_labels()))


    def usage_string_for_list(self):
      template = '''Usage:
          list ({options})
      '''
      return template.format(options=' | '.join(self.config_object_plural_labels()))


    def get_selected_option(self, arg_dict, option_list):
      for item in option_list:
        if arg_dict.get(item) == True:
          return item
      return None


    @contextmanager
    def docopt_parse(self, usage_string, *cmd_args):
      try:
        args = docopt.docopt(usage_string, *cmd_args)
        yield args, None            

      except DocoptExit as e:
        # The DocoptExit is thrown when the args do not match.
        # We print a message to the user and the usage block.

        error_msg = '\nPlease specify one or more valid command parameters.\n%s\n' % e
        yield None, error_msg

      except SystemExit:
        # The SystemExit exception prints the usage for --help
        # We do not need to do the print here.
        raise


    def do_list(self, *cmd_args):
      with self.docopt_parse(self.usage_string_for_list(), *cmd_args) as (args, error):
        if not error:
          selection = self.get_selected_option(args, self.config_object_plural_labels())
          pkg = self.find_config_package_by_plural_label(selection)
          if not pkg:
            print('!!! ERROR: No configuration package found with label "%s".' % selection)

          list_function = pkg['list_func']
          if not self.configuration.get(pkg['name']):
            self.configuration[pkg['name']] = []
          objects_to_list = self.configuration[pkg['name']]
          list_function(objects_to_list)
        else:
          print(error)

    do_ls = do_list


    def do_new(self, *cmd_args):            
      with self.docopt_parse(self.usage_string_for_new(), *cmd_args) as (args, error):
        if not error:
          
          selection = self.get_selected_option(args, self.config_object_singular_labels())        
          pkg = self.find_config_package_by_singular_label(selection)
          if not pkg:
            print('!!! ERROR: No configuration package found with label "%s".' % selection)
            return
          if pkg.get('singleton') == True and len(self.configuration.get(pkg['name'], [])) == pkg.get('unit_size'):
            print('Cannot create more than one "%s" config section.' % selection)
            return

          # create func should always be a generator
          config_objects = pkg['create_func'](self.configuration, pkg) 
          #print(common.jsonpretty([obj.data() for obj in config_objects]))

          if not self.configuration.get(pkg['name']):
            self.configuration[pkg['name']] = []

          for obj in config_objects:
            self.configuration[pkg['name']].append(obj)
          
          #print(common.jsonpretty(self.configuration))
          self.do_pre()
        else:
          print(error)

    do_n = do_new

    def do_wizard(self, *cmd_args):
      for config_object_type in self.target_package['config_object_types']:
        self.do_new(config_object_type['singular_label'])
        clear()

      self.do_preview()


    def find_config_data(self, config_obj_array, target):
      print('names of config objects under edit:')
      for config_object in config_obj_array:
        if config_object.name == target:
          return config_object
    
    def update_config_data(self, config_obj_array, name, value):
      config_object = self.find_config_data(config_obj_array, name)
      if config_object:
        config_object.value = value


    def globals_config_section_to_menu(self, config_section):
      menudata = []
      for name, setting in config_section.items():
        menudata.append({
          'label': '%s (current: %s)' % (name, setting),
          'value': name
        })
        return menudata

    def find_config_object(self, attrib, config_object_array, target_pkg):
      for obj in config_object_array:
        if getattr(obj, target_pkg['index_attribute']) == attrib:
          return obj

    def generate_menu_data(self, config_object_array, target_pkg):
      menudata = []
      for obj in config_object_array:
        menudata.append({
          'value': getattr(obj, target_pkg['index_attribute']),
          'label': getattr(obj, target_pkg['index_attribute'])
        })
      return menudata

    def do_edit(self, *cmd_args):
      with self.docopt_parse(self.usage_string_for_edit(), *cmd_args) as (args, error):
        if not error:
          selection = self.get_selected_option(args, self.config_object_singular_labels())

          pkg = self.find_config_package_by_singular_label(selection)
          if not pkg:
            print('!!! ERROR: No configuration package found with label "%s".' % selection)
            return
          if not self.configuration.get(pkg['name']):
            print('No %s yet configured.' % pkg['name'])
          else:

            config_obj_array = self.configuration[pkg['name']]
            #print('::: Edit %s' % selection)

            #if selection != 'globals' and len(config_obj_array) > 1:
            object_menudata = self.generate_menu_data(config_obj_array, pkg)
            object_name = cli.MenuPrompt('object to edit', object_menudata).show()
            config_object = self.find_config_object(object_name, config_obj_array, pkg)

            pkg['update_func']([config_object])
            #else:
            #  pkg['update_func'](config_obj_array)

            self.do_list(pkg['plural_label'])      
        else:
          print(error)


    def do_preview(self, *cmd_args):
      yconf = self.generate_yaml_config()
      print(yconf)

    do_pre = do_preview


    def do_validate(self, *cmd_args):
      validate = self.target_package['validator_func']
      yaml_config = self.generate_yaml_config()
      is_ok, errors = validate(yaml_config, self.configuration)
      if is_ok:
        print('***')
        print('*** Configuration is valid.')
        print('***')
        return True
      else:
        print('!!!')
        print('!!! The current configuration contains errors:')
        for err in errors:
          print('!!! * %s%s' % (tab(1), err))
        print('!!!')
        return False

    do_val = do_validate

    def do_save(self, *cmd_args):

      # TODO: validate config first
      print('***')
      print('*** Save xfile configuration file')
      print('***')
      
      while True:
        filename = cli.InputPrompt('output filename ').show()
        if not filename:
          return
        if os.path.isfile(filename):
          answer = cli.InputPrompt('filename "%s" already exists. Overwrite (y/N)?' % filename, 'n').show()
          should_overwrite = answer.lower()
          if should_overwrite == 'n':
            print('\n')
            continue

        yaml_config = self.generate_yaml_config()
        with open(filename, 'w') as f:
          f.write(yaml_config)
        break


    def do_quit(self, *cmd_args):
        print('%s CLI exiting.' % self.name)        
        raise SystemExit

    do_q = do_quit


    def do_cls(self, *cmd_args):
      clear()



def main(args):
    if args['--list']:
      print(BANNER)
      for name, target in targets.items():
        print('|: %s (%s)' % (name, target['description']))
        print('|:')      
      print(BANNER_CLOSE)
      return

    config_target_name = args['<target>']
    target_pkg = targets.get(config_target_name)
    if not target_pkg:
      print('Unsupported configuration target: %s' % config_target_name)
      return

    clear()
    config_cli = ConfigCLI('mkcfg', config_target_name, target_pkg)
    config_cli.cmdloop()

if __name__ == '__main__':
    args = docopt.docopt(__doc__)
    main(args)