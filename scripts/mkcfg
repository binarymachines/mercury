#!/usr/bin/env python

'''
Usage:
  mkcfg --list
  mkcfg <target>

Options:
  -l --list-targets       show the available configuration targets
'''

import os, sys
from os import system, name
from contextlib import contextmanager
import copy
import itertools
from enum import Enum
from cmd import Cmd
from snap import common
from snap import cli_tools as cli
from mercury import configtemplates as templates
from mercury import metaobjects as meta
import docopt
from docopt import docopt as docopt_func
from docopt import DocoptExit
import jinja2


BANNER = '''
___________________________________________________________________________
|::
|:: mkcfg interactive configfile generator
|:: issue "mkcfg <target>" to create a config file for a target utility.
|::
|::
|:: available config targets:
|:'''

BANNER_CLOSE = '|__________________________________________________________________________\n'


class Whitespace(Enum):
  space = ' '
  tab = '\t'


def tab(num_tabs):
  return ''.join(itertools.repeat('\t', num_tabs))
  

def space(num_spaces):
  return ''.join(itertools.repeat(' ', num_spaces))


def indent(num_indents, whitespace_type):
  return ''.join(itertools.repeat(whitespace_type, num_indents))

def clear(): 
    # for windows 
    if name == 'nt': 
        _ = system('cls') 

    # for mac and linux(here, os.name is 'posix') 
    else: 
        _ = system('clear') 


service_object_sequence = {
  'marquee': '''
  +++
  +++ Register service object
  +++
  ''',
  'steps': [
    {
      'field_name': 'alias',
      'prompt': cli.InputPrompt('service object alias'),
      'required': True
    },
    {
      'field_name': 'class',
      'prompt': cli.InputPrompt('service object class'),
      'required': True
    }
  ]

}

XFILE_FIELD_SOURCE_TYPES = [
  {'value': 'record', 'label': 'input record'},
  {'value': 'lookup', 'label': 'lookup function'},
  {'value': 'lambda', 'label': 'lambda expression'}
]

xfile_field_src_lambda = {
  'marquee': '''
  :::
  ::: set lambda-type field params
  :::
  ''',
  'inputs': {
    'source': 'lambda'
  },  
  'steps': [
    {
      'field_name': 'key',
      'prompt': cli.InputPrompt('field from source record:'),
      'required': True
    },
    {
      'field_name': 'expression',
      'prompt': cli.InputPrompt('lambda expression:'),
      'required': True
    },
  ]
}

xfile_field_src_record = {
  'marquee': '''
  :::
  ::: set record-type field params
  :::
  ''',
  'inputs': {},
  'builder_func': lambda **kwargs: meta.XfileFieldSpec(kwargs['inputs']['name'],
                                                       **(kwargs['outputs'])),
  'steps': [
    {
      'field_name': 'key',
      'prompt': cli.InputPrompt('field from source record:'),
      'required': True
    },
  ]
}

xfile_field_src_lookup = {
  'marquee': '''
  :::
  ::: set record-type field params
  :::
  ''',
  'inputs': {},
  'builder_func': lambda **kwargs: meta.XfileFieldSpec(kwargs['inputs']['name'],
                                                       **(kwargs['outputs'])),
  'steps': [
    {
      'field_name': 'key',
      'prompt': cli.InputPrompt('field from source record:'),
      'required': True
    },
  ]
}


def new_xfile_fieldspec(**kwargs):
  return meta.XfileFieldSpec(kwargs['field_name'], **kwargs['field_params'])
                             

xfile_field_sequence = {
  'marquee': '''
  +++ 
  +++ Add field to xfile record map
  +++
  ''',
  'builder_func': new_xfile_fieldspec,
  'steps': [
    {
      'field_name': 'field_name',
      'prompt': cli.InputPrompt('output field name'),
      'required': True
    },
    {
      'field_name': 'field_params',
      'prompt': cli.MenuPrompt('field source:', XFILE_FIELD_SOURCE_TYPES),
      'required': True,
      'conditions': {
        'lambda': {  
          'sequence': xfile_field_src_lambda
        },
        'record': {
          'sequence': xfile_field_src_record
        },
      } 
    }
  ]
}

xfile_map_sequence = {
  'marquee': '''
  +++
  +++ Create new xfile map
  +++
  ''',
  'builder_func': lambda **kwargs: meta.XfileMapSpec(kwargs['map_name'], kwargs['lookup_source']),
  'steps': [
    {
      'field_name': 'map_name',
      'prompt': cli.InputPrompt('map name'),
      'required': True
    },
    {
      'field_name': 'lookup_source',
      'prompt': cli.InputPrompt('lookup datasource name'),
      'required': True
    }
  ]
}


xfile_globals_interaction_sequence = {
  'marquee': '''
  +++ 
  +++ Create global settings group
  +++
  ''',
  'steps': [
    {
      'field_name': 'project_home',
      'prompt': cli.InputPrompt('project home'),
      'required': True
    },
    {
      'field_name': 'datasource module',
      'prompt': cli.InputPrompt('datasource module'),
      'required': True
    },
    {
      'field_name': 'service module',
      'prompt': cli.InputPrompt('service module'),
      'required': True
    }
  ]
}

xfile_datasource_sequence = {
  'marquee': '''
  +++
  +++ Register datasource
  +++
  ''',
  'steps': [
    {
      'field_name': 'alias',
      'prompt': cli.InputPrompt('datasource alias'),
      'required': True
    },
    {
      'field_name': 'class',
      'prompt': cli.InputPrompt('datasource class'),
      'required': True 
    }
  ]
}

class UISequenceRunner(object):
  def __init__(self):
    pass

  def process_sequence(self, init_context=None, **sequence):
    print(sequence['marquee'])
    context = {}
    if init_context:
      context.update(init_context)
    
    if sequence.get('inputs'):
      context.update(sequence['inputs'])

    for step in sequence['steps']:
      
      answer = step['prompt'].show()
      if answer is None and step['required'] == True:        
        break

      if answer is None and hasattr(step, 'default'):        
        answer = step['default']

      if step.get('conditions'):        
        if not step['conditions'].get(answer):
          raise Exception('a step in the UI sequence returned an answer "%s" for which there is no condition.' % answer)
        next_sequence = step['conditions'][answer]['sequence']
        outgoing_context = copy.deepcopy(context)
        context[step['field_name']] = self.process_sequence(**next_sequence)

      else:        
        context[step['field_name']] = answer
  
    print(common.jsonpretty(context))
    return context

  def run(self, **sequence):
    context = self.process_sequence(**sequence)
    output_builder = sequence.get('builder_func')
    if output_builder:
      return output_builder(**context)
    return context


def find_global_by_name():
  pass

def find_service_object_by_name():
  pass

def find_dfproc_processor_by_name():
  pass

def find_xfile_map_by_name():
  pass

def find_xfile_datasource_by_name():
  pass

def find_ngst_datastore_by_name():
  pass

def find_ngst_target_by_name():
  pass

def find_cyclops_trigger_by_name():
  pass

def find_j2sqlgen_target_by_name():
  pass

def find_j2sqlgen_default_by_name():
  pass

def find_pgexec_target_by_name():
  pass

def find_profiler_by_name():
  pass

def find_profilr_dataset_by_name():
  pass

def find_quasr_template_by_name():
  pass

def find_quasr_job_by_name():
  pass


def create_global():
  # this will return a dictionary containing all global parameters for an xfile project
  result =  UISequenceRunner().run(**xfile_globals_interaction_sequence)

  # return all Parameter specs
  for key, value in result.items():
    yield meta.Parameter(name=key, value=value)


def create_service_object_params():
  so_params = {}
  while True:
      param_name = cli.InputPrompt('parameter name').show()
      if not param_name:
          break
      param_value = cli.InputPrompt('parameter value').show()
      if not param_value:
          break

      so_params[param_name] = param_value

      should_continue = cli.InputPrompt('add another parameter (Y/n)?', 'y').show()
      if should_continue.lower() != 'y':
          break

  return so_params


def create_service_object(name=None):
  data = UISequenceRunner().run(**service_object_sequence)
  if data:
    yield meta.ServiceObjectSpec(data['alias'], data['class'])
  return None

  
def create_dfproc_processor():
  pass


def create_xfile_datasource(name=None):
  data = UISequenceRunner().run(**xfile_datasource_sequence)
  if data:
    yield meta.DatasourceSpec(data['alias'], data['class'])
  return None
  

def create_xfile_map(name=None):
  mapspec = UISequenceRunner().run(**xfile_map_sequence)
  while True:
    fieldspec = UISequenceRunner().run(**xfile_field_sequence)
    mapspec.add_field_spec(fieldspec)
    break
  
  yield mapspec


def create_ngst_target():
  pass

def create_ngst_datastore():
  pass

def create_cyclops_trigger():
  pass

def create_j2sqlgen_default():
  pass

def create_j2sqlgen_target():
  pass

def create_pgexec_target():
  pass

def create_profiler():
  pass

def create_profilr_dataset():
  pass

def create_quasr_template():
  pass

def create_quasr_job():
  pass

def edit_global():
  pass

def edit_service_object():
  pass

def edit_dfproc_processor():
  pass

def edit_xfile_datasource():
  pass

def edit_xfile_map():
  pass

def edit_ngst_datastore():
  pass

def edit_ngst_target():
  pass

def edit_cyclops_trigger():
  pass

def edit_j2sqlgen_default():
  pass

def edit_j2sqlgen_target():
  pass

def edit_pgexec_target():
  pass

def edit_profiler():
  pass

def edit_profilr_dataset():
  pass

def edit_quasr_template():
  pass

def edit_quasr_job():
  pass

def list_globals(global_settings):
  if not len(global_settings):
    print('No globals registered.')
    return
  
  print('globals:')
  for gs in global_settings:
    print('%s%s: %s' % (tab(1), gs.name, gs.value))
  

def list_service_objects(service_objects):
  if not len(service_objects):
    print('No service objects registered.')
    return

  print('service_objects:')
  for so in service_objects:
    print('%s%s:' % (tab(1), so.alias))
    print('%sclass: %s' % (tab(2), so.classname))
    print('%sinit_params:' % tab(2))
    for p in so.init_params:
      print('%s- name: %s' % (tab(3), p.name))
      print('%s  value: %s' % (tab(3), p.value))


def list_dfproc_processors():
  pass

def list_xfile_datasources(datasources):
  if not len(datasources):
    print("No datasources registered.")
    return
  

def list_xfile_maps(maps):
  if not len(maps):
    print("No maps registered.")
    return

  print('maps:')
  for mapspec in maps:
    print('%s%s:' % (tab(1), mapspec.name))
    for field in mapspec.fields:
      print('%s- %s:' % (tab(2), field.name))
      for param in field.parameters:
        print('%s%s: %s' % (tab(3), param.name, param.value))


def list_ngst_datastores():
  pass

def list_ngst_targets():
  pass

def list_cyclops_triggers():
  pass

def list_j2sqlgen_defaults():
  pass

def list_j2sqlgen_targets():
  pass

def list_pgexec_targets():
  pass

def list_profilers():
  pass

def list_profilr_datasets():
  pass

def list_quasr_templates():
  pass

def list_quasr_jobs():
  pass


def validate_xfile_config():
  pass



targets = {
  'dfproc': {
    'description': 'Create and transform Pandas dataframes',
    'template': templates.DFPROC_TEMPLATE,    
    'config_object_types': [
      {
        'name': 'globals',
        'singular_label': 'global',
        'find_func': find_global_by_name,
        'create_func': create_global,
        'update_func': edit_global,
        'list_func': list_globals
      },
      {
        'name': 'service_objects',
        'singular_label': 'service object',
        'find_func': find_service_object_by_name,
        'create_func': create_service_object,
        'update_func': edit_service_object,
        'list_func': list_service_objects
      },
      {
        'name': 'processors',
        'singular_label': 'dataframe processor',
        'find_func': find_dfproc_processor_by_name,
        'create_func': create_dfproc_processor,
        'update_func': edit_dfproc_processor,
        'list_func': list_dfproc_processors
      }
    ]
  },
  'xfile': {
    'description': 'Read and transform CSV or JSON records',
    'template': templates.XFILE_TEMPLATE,
    'validator_func': validate_xfile_config,
    'config_object_types': [
      {
        'name': 'globals',
        'singular_label': 'globals',
        'plural_label': 'globals',
        'find_func': find_global_by_name,
        'create_func': create_global,
        'update_func': edit_global,
        'list_func': list_globals,
      },
      {
        'name': 'service_objects',
        'singular_label': 'service',
        'plural_label': 'services',
        'find_func': find_service_object_by_name,
        'create_func': create_service_object,
        'update_func': edit_service_object,
        'list_func': list_service_objects        
      },
      {
        'name': 'sources', 
        'singular_label': 'datasource',
        'plural_label': 'datasources',
        'find_func': find_xfile_datasource_by_name,
        'create_func': create_xfile_datasource,
        'update_func': edit_xfile_datasource,
        'list_func': list_xfile_datasources
      },
      {
        'name': 'maps',
        'singular_label': 'map',
        'plural_label': 'maps',
        'find_func': find_xfile_map_by_name,
        'create_func': create_xfile_map,
        'update_func': edit_xfile_map,
        'list_func': list_xfile_maps
      } 
    ]
  },
  'ngst': {
    'description': 'Send CSV or JSON records to a designated target',
    'template': templates.NGST_TEMPLATE,
    'config_object_types': [
      {
        'name': 'globals',
        'singular_label': 'global',
        'find_func': find_global_by_name,
        'create_func': create_global,
        'update_func': edit_global,
        'list_func': list_globals
      },
      {
        'name': 'service_objects',
        'singular_label': 'service object',
        'find_func': find_service_object_by_name,
        'create_func': create_service_object,
        'update_func': edit_service_object,
        'list_func': list_service_objects        
      },
      {
        'name': 'datastores',
        'singular_label': 'ngst datastore',
        'find_func': find_ngst_datastore_by_name,
        'create_func': create_ngst_datastore,
        'update_func': edit_ngst_datastore,
        'list_func': list_ngst_datastores
      },
      {
        'name': 'ingest_targets',
        'singular_label': 'ingest target',
        'find_func': find_ngst_target_by_name,
        'create_func': create_ngst_target,
        'update_func': edit_ngst_target,
        'list_func': list_ngst_targets
      }
    ]
  },
  'cyclops': {
    'description': 'Run custom code in response to filesystem events',
    'template': templates.CYCLOPS_TEMPLATE,
    'config_object_types': [
      {
        'name': 'globals',
        'singular_label': 'global',
        'find_func': find_global_by_name,
        'create_func': create_global,
        'update_func': edit_global,
        'list_func': list_globals
      },
      {
        'name': 'service_objects',
        'singular_label': 'service object',
        'find_func': find_service_object_by_name,
        'create_func': create_service_object,
        'update_func': edit_service_object,
        'list_func': list_service_objects        
      },
      {
        'name': 'triggers',
        'singular_label': 'filesystem event trigger',
        'find_func': find_cyclops_trigger_by_name,
        'create_func': create_cyclops_trigger,
        'update_func': edit_cyclops_trigger,
        'list_func': list_cyclops_triggers
      }
    ]
  },
  'j2sqlgen': {
    'description': 'Generate CREATE TABLE sql statements from JSON metadata',
    'template': templates.J2SQLGEN_TEMPLATE,
    'config_object_types': [
      {
        'name': 'globals',
        'singular_label': 'global',
        'find_func': find_global_by_name,
        'create_func': create_global,
        'update_func': edit_global,
        'list_func': list_globals
      },
      {
        'name': 'defaults',
        'singular_label': 'SQL generation default',
        'find_func': find_j2sqlgen_default_by_name,
        'create_func': create_j2sqlgen_default,
        'update_func': edit_j2sqlgen_default,
        'list_func': list_j2sqlgen_defaults
      },
      {
        'name': 'tables',
        'singular_label': 'j2sql target table',
        'find_func': find_j2sqlgen_target_by_name,
        'create_func': create_j2sqlgen_target,
        'update_func': edit_j2sqlgen_target,
        'list_func': list_j2sqlgen_targets
      }
    ]
  },
  'pgexec': {
    'description': 'Execute SQL commands against a PostgreSQL database',
    'template': templates.PGEXEC_TEMPLATE,
    'config_object_types': [
        {
          'name': 'targets',
          'singular_label': 'target',
          'find_func': find_pgexec_target_by_name,
          'create_func': create_pgexec_target,
          'update_func': edit_pgexec_target,
          'list_func': list_pgexec_targets
        },
      ]
  },
  'pgmeta': {
    'description': 'Extract table metadata as JSON from a PostgreSQL database',
    'template': templates.PGMETA_TEMPLATE,
    'config_object_types': [
        {
          'name': 'targets',
          'singular_label': 'target',
          'find_func': find_pgexec_target_by_name, # pgmeta and pgexec use the same target
          'create_func': create_pgexec_target,
          'update_func': edit_pgexec_target,
          'list_func': list_pgexec_targets
        }
      ]
  },
  'profilr': {
    'description': 'Run custom data profiling logic against a file-based dataset',
    'template': templates.PROFILR_TEMPLATE,
    'config_object_types': [
        {
        'name': 'globals',
        'singular_label': 'global',
        'find_func': find_global_by_name,
        'create_func': create_global,
        'update_func': edit_global,
        'list_func': list_globals
      },
      {
        'name': 'service_objects',
        'singular_label': 'service object',
        'find_func': find_service_object_by_name,
        'create_func': create_service_object,
        'update_func': edit_service_object,
        'list_func': list_service_objects
      },
      {
        'name': 'profilers',
        'singular_label': 'profiler',
        'find_func': find_profiler_by_name,
        'create_func': create_profiler,
        'update_func': edit_profiler,
        'list_func': list_profilers
      },
      {
        'name': 'datasets',
        'singular_label': 'profilr dataset',
        'find_func': find_profilr_dataset_by_name,
        'create_func': create_profilr_dataset,
        'update_func': edit_profilr_dataset,
        'list_func': list_profilr_datasets
      }
    ]
  },
  'quasr': {
    'description': 'Run custom QA/profiling code against a relational dataset',
    'template': templates.QUASR_TEMPLATE,
    'config_object_types': [
      {
        'name': 'globals',
        'singular_label': 'global',
        'find_func': find_global_by_name,
        'create_func': create_global,
        'update_func': edit_global,
        'list_func': list_globals
      },
      {
          'name': 'service_objects',
          'singular_label': 'service object',
          'find_func': find_service_object_by_name,
          'create_func': create_service_object,
          'update_func': edit_service_object,
          'list_func': list_service_objects
      },
      {
          'name': 'templates',
          'singular_label': 'template',
          'find_func': find_quasr_template_by_name,
          'create_func': create_quasr_template,
          'update_func': edit_quasr_template,
          'list_func': list_quasr_templates
      },
      {
          'name': 'jobs',
          'singular_label': 'job',
          'find_func': find_quasr_job_by_name,
          'create_func': create_quasr_job,
          'update_func': edit_quasr_job,
          'list_func': list_quasr_jobs
      }
    ]
  }
}


def docopt_cmd(func):
    """
    This decorator is used to simplify the try/except block and pass the result
    of the docopt parsing to the called action.
    """
    def fn(self, arg):
        try:
            opt = docopt_func(fn.__doc__, arg)
            #opt = docopt_func(usage_string, arg)

        except DocoptExit as e:
            # The DocoptExit is thrown when the args do not match.
            # We print a message to the user and the usage block.

            print('\nPlease specify one or more valid command parameters.')
            print(e)
            return

        except SystemExit:
            # The SystemExit exception prints the usage for --help
            # We do not need to do the print here.
            return

        return func(self, opt)

    fn.__name__ = func.__name__
    fn.__doc__ = func.__doc__
    fn.__dict__.update(func.__dict__)
    return fn


def docstring(docstr, sep="\n"):
    """
    Decorator: Append to a function's docstring.
    """
    def _decorator(func):
        if func.__doc__ == None:
            func.__doc__ = docstr
        else:
            func.__doc__ = sep.join([func.__doc__, docstr])
        return func
    return _decorator


class ConfigCLI(Cmd):
    def __init__(self,
                 name,
                 target_name,
                 target_package,
                 **kwargs):

        Cmd.__init__(self)
        self.name = name
        self.prompt = '__%s [%s]> ' % (self.name, target_name)
        self.target_package = target_package
        self.configuration = {}
        #self.replay_stack = Stack()


    def build_project(self, config):
      return {}

    def generate_yaml_config(self):
      print(self.configuration)
      config_template = self.target_package['template']
      prj = self.build_project(self.configuration)
      j2template = jinja2.Environment(loader=jinja2.BaseLoader).from_string(config_template)
      yaml_conf = j2template.render(project=self.configuration)
      return yaml_conf
      
    def find_config_package_by_plural_label(self, label):
      for config_object_type in self.target_package['config_object_types']:
        if config_object_type['plural_label'] == label:
          return config_object_type


    def find_config_package_by_singular_label(self, label):
      for config_object_type in self.target_package['config_object_types']:
        if config_object_type['singular_label'] == label:
          return config_object_type
      

    def config_object_singular_labels(self):
      return [conftype['singular_label'] for conftype in self.target_package['config_object_types']]


    def config_object_plural_labels(self):
      return [conftype['plural_label'] for conftype in self.target_package['config_object_types']]


    def usage_string_for_new(self):
      template = '''Usage:
          new ({options})
      '''
      return template.format(options=' | '.join(self.config_object_singular_labels()))
    

    def usage_string_for_find(self):
      template = '''Usage:
          find ({options})
      '''      
      return template.format(options=' | '.join(self.config_object_singular_labels()))


    def usage_string_for_list(self):
      template = '''Usage:
          list ({options})
      '''
      return template.format(options=' | '.join(self.config_object_plural_labels()))


    def get_selected_option(self, arg_dict, option_list):
      for item in option_list:
        if arg_dict.get(item) == True:
          return item
      return None


    @contextmanager
    def docopt_parse(self, usage_string, *cmd_args):
      try:
        args = docopt.docopt(usage_string, *cmd_args)
        yield args, None            

      except DocoptExit as e:
        # The DocoptExit is thrown when the args do not match.
        # We print a message to the user and the usage block.

        error_msg = '\nPlease specify one or more valid command parameters.\n%s\n' % e
        yield None, error_msg

      except SystemExit:
        # The SystemExit exception prints the usage for --help
        # We do not need to do the print here.
        raise


    def do_list(self, *cmd_args):
      with self.docopt_parse(self.usage_string_for_list(), *cmd_args) as (args, error):
        if not error:
          selection = self.get_selected_option(args, self.config_object_plural_labels())
          pkg = self.find_config_package_by_plural_label(selection)
          if not pkg:
            print('!!! ERROR: No configuration package found with label "%s".' % selection)

          list_function = pkg['list_func']
          if not self.configuration.get(pkg['name']):
            self.configuration[pkg['name']] = []
          objects_to_list = self.configuration[pkg['name']]
          list_function(objects_to_list)
        else:
          print(error)

    do_ls = do_list

    def do_new(self, *cmd_args):            
      with self.docopt_parse(self.usage_string_for_new(), *cmd_args) as (args, error):
        if not error:
          
          selection = self.get_selected_option(args, self.config_object_singular_labels())        
          pkg = self.find_config_package_by_singular_label(selection)
          if not pkg:
            print('!!! ERROR: No configuration package found with label "%s".' % selection)

          # create func should always be a generator
          config_objects = pkg['create_func']() 

          if not self.configuration.get(pkg['name']):
            self.configuration[pkg['name']] = []

          for obj in config_objects:
            self.configuration[pkg['name']].append(obj)

        else:
          print(error)

    do_n = do_new

    def do_preview(self, *cmd_args):
      yconf = self.generate_yaml_config()
      print(yconf)

    do_pre = do_preview


    def do_validate(self, *cmd_args):
      validate = self.target_package['validator_func']
      yaml_config = self.generate_yaml_config()
      errors = validate(yaml_config)
      if not len(errors):
        print('+++')
        print('+++ Configuration is valid.')
        print('+++')
        return True
      else:
        print('!!!')
        print('!!! The current configuration contains errors:')
        for err in errors:
          print('!%s%s' % (tab(1), err))
        print('!!!')
        return False

    do_val = do_validate

    def do_save(self, *cmd_args):

      # TODO: validate config first
      print('***')
      print('*** Save xfile configuration file')
      print('***')
      
      while True:
        filename = cli.InputPrompt('output filename ').show()
        if not filename:
          return
        if os.path.isfile(filename):
          answer = cli.InputPrompt('filename "%s" already exists. Overwrite (y/N)?' % filename, 'n').show()
          should_overwrite = answer.lower()
          if should_overwrite == 'n':
            print('\n')
            continue

        yaml_config = self.generate_yaml_config()
        with open(filename, 'w') as f:
          f.write(yaml_config)
        break


    def do_quit(self, *cmd_args):
        print('%s CLI exiting.' % self.name)        
        raise SystemExit

    do_q = do_quit


def main(args):
    if args['--list']:
      print(BANNER)
      for name, target in targets.items():
        print('|: %s (%s)' % (name, target['description']))
        print('|:')      
      print(BANNER_CLOSE)
      return

    config_target_name = args['<target>']
    target_pkg = targets.get(config_target_name)
    if not target_pkg:
      print('Unsupported configuration target: %s' % config_target_name)
      return

    clear()
    config_cli = ConfigCLI('mkcfg', config_target_name, target_pkg)
    config_cli.cmdloop()

if __name__ == '__main__':
    args = docopt.docopt(__doc__)
    main(args)