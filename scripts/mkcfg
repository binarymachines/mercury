#!/usr/bin/env python

'''
Usage:
  mkcfg --list-targets
  mkcfg <target>

Options:
  -l --list-targets       show the available configuration targets
'''

import os, sys
from contextlib import contextmanager
import itertools
from enum import Enum
from cmd import Cmd
from snap import cli_tools as cli
from mercury import configtemplates as templates
from mercury import metaobjects as meta
import docopt
from docopt import docopt as docopt_func
from docopt import DocoptExit


BANNER = '''
___________________________________________________________________________
|::
|:: mkcfg interactive configfile generator
|:: issue "mkcfg <target>" to create a config file for a target utility.
|::
|::
|:: available config targets:
|:'''

BANNER_CLOSE = '|__________________________________________________________________________\n'


class Whitespace(Enum):
  space = ' '
  tab = '\t'


def tab(num_tabs):
  return ''.join(itertools.repeat('\t', num_tabs))
  

def space(num_spaces):
  return ''.join(itertools.repeat(' ', num_spaces))


def indent(num_indents, whitespace_type):
  return ''.join(itertools.repeat(whitespace_type, num_indents))


def find_global_by_name():
  pass

def find_service_object_by_name():
  pass

def find_dfproc_processor_by_name():
  pass

def find_xfile_map_by_name():
  pass

def find_xfile_datasource_by_name():
  pass

def find_ngst_datastore_by_name():
  pass

def find_ngst_target_by_name():
  pass

def find_cyclops_trigger_by_name():
  pass

def find_j2sqlgen_target_by_name():
  pass

def find_j2sqlgen_default_by_name():
  pass

def find_pgexec_target_by_name():
  pass

def find_profiler_by_name():
  pass

def find_profilr_dataset_by_name():
  pass

def find_quasr_template_by_name():
  pass

def find_quasr_job_by_name():
  pass

def create_global():
  pass


def create_service_object_params():
  so_params = {}
  while True:
      param_name = cli.InputPrompt('parameter name').show()
      if not param_name:
          break
      param_value = cli.InputPrompt('parameter value').show()
      if not param_value:
          break

      so_params[param_name] = param_value

      should_continue = cli.InputPrompt('add another parameter (Y/n)?', 'y').show()
      if should_continue.lower() != 'y':
          break

  return so_params


def create_service_object(name=None):
  print('+++')
  print('+++ Register new service object')
  print('+++')
  so_name = name or cli.InputPrompt('service object name').show()
  so_classname = cli.InputPrompt('service object class').show()
  so_params = create_service_object_params()
  return meta.ServiceObjectSpec(so_name, so_classname, **so_params)

  
def create_dfproc_processor():
  pass

def create_xfile_datasource(name=None):
  pass


def create_xfile_fields():
  print('+++')
  print('+++ Add fields to this map')
  print('+++')
  fieldspecs = []
  while True:
      field_name = cli.InputPrompt('field name').show()
      if not field_name:
          break
      
      fieldspec = meta.XfileFieldSpec(field_name)

      should_add_parameters = cli.InputPrompt('add parameters to this field (Y/n)?', 'y').show()
      if should_add_parameters.lower() == 'y':
        while True:
          param_name = cli.InputPrompt('parameter name').show()
          if not param_name:
              break
          param_value = cli.InputPrompt('parameter value').show()
          if param_value is None:
            param_value = ''
          
          fieldspec.add_parameter(param_name, param_value)
          should_continue = cli.InputPrompt('add another parameter (Y/n)?', 'y').show()
          if should_continue.lower() != 'y':
            break

      fieldspecs.append(fieldspec)
      should_continue = cli.InputPrompt('add another field (Y/n)?', 'y').show()
      if should_continue.lower() != 'y':
          break

  return fieldspecs


def create_xfile_map(name=None):
  print('+++')
  print('+++ Register new xfile map')
  print('+++')
  map_name = name or cli.InputPrompt('map name').show()

  map_fields = create_xfile_fields()
  lookup_src_name = 'nosource'
  mapspec = meta.XfileMapSpec(map_name, lookup_src_name)
  mapspec.add_field_specs(map_fields)
  return mapspec


def create_ngst_target():
  pass

def create_ngst_datastore():
  pass

def create_cyclops_trigger():
  pass

def create_j2sqlgen_default():
  pass

def create_j2sqlgen_target():
  pass

def create_pgexec_target():
  pass

def create_profiler():
  pass

def create_profilr_dataset():
  pass

def create_quasr_template():
  pass

def create_quasr_job():
  pass

def edit_global():
  pass

def edit_service_object():
  pass

def edit_dfproc_processor():
  pass

def edit_xfile_datasource():
  pass

def edit_xfile_map():
  pass

def edit_ngst_datastore():
  pass

def edit_ngst_target():
  pass

def edit_cyclops_trigger():
  pass

def edit_j2sqlgen_default():
  pass

def edit_j2sqlgen_target():
  pass

def edit_pgexec_target():
  pass

def edit_profiler():
  pass

def edit_profilr_dataset():
  pass

def edit_quasr_template():
  pass

def edit_quasr_job():
  pass

def list_globals():
  pass

def list_service_objects(service_objects):
  if not len(service_objects):
    print('No service objects registered.')
    return

  print('service_objects:')
  for so in service_objects:
    print('%s%s:' % (tab(1), so.alias))
    print('%sclass: %s' % (tab(2), so.classname))
    print('%sinit_params:' % tab(2))
    for p in so.init_params:
      print('%s- name: %s' % (tab(3), p.name))
      print('%s  value: %s' % (tab(3), p.value))


def list_dfproc_processors():
  pass

def list_xfile_datasources(datasources):
  if not len(datasources):
    print("No datasources registered.")
    return

def list_xfile_maps(maps):
  if not len(maps):
    print("No maps registered.")
    return

  print('maps:')
  for mapspec in maps:
    print('%s%s:' % (tab(1), mapspec.name))
    for field in mapspec.fields:
      print('%s- %s:' % (tab(2), field.name))
      for param in field.parameters:
        print('%s%s: %s' % (tab(3), param.name, param.value))

def list_ngst_datastores():
  pass

def list_ngst_targets():
  pass

def list_cyclops_triggers():
  pass

def list_j2sqlgen_defaults():
  pass

def list_j2sqlgen_targets():
  pass

def list_pgexec_targets():
  pass

def list_profilers():
  pass

def list_profilr_datasets():
  pass

def list_quasr_templates():
  pass

def list_quasr_jobs():
  pass


def validate_xfile_config():
  pass

targets = {
  'dfproc': {
    'description': 'Create and transform Pandas dataframes',
    'template': templates.DFPROC_TEMPLATE,    
    'config_object_types': [
      {
        'name': 'globals',
        'singular_label': 'global',
        'find_func': find_global_by_name,
        'create_func': create_global,
        'update_func': edit_global,
        'list_func': list_globals
      },
      {
        'name': 'service_objects',
        'singular_label': 'service object',
        'find_func': find_service_object_by_name,
        'create_func': create_service_object,
        'update_func': edit_service_object,
        'list_func': list_service_objects
      },
      {
        'name': 'processors',
        'singular_label': 'dataframe processor',
        'find_func': find_dfproc_processor_by_name,
        'create_func': create_dfproc_processor,
        'update_func': edit_dfproc_processor,
        'list_func': list_dfproc_processors
      }
    ]
  },
  'xfile': {
    'description': 'Read and transform CSV or JSON records',
    'template': templates.XFILE_TEMPLATE,
    'validator_func': validate_xfile_config,
    'config_object_types': [
      {
        'name': 'globals',
        'singular_label': 'global',
        'plural_label': 'globals',
        'find_func': find_global_by_name,
        'create_func': create_global,
        'update_func': edit_global,
        'list_func': list_globals,
      },
      {
        'name': 'service_objects',
        'singular_label': 'service_object',
        'plural_label': 'service_objects',
        'find_func': find_service_object_by_name,
        'create_func': create_service_object,
        'update_func': edit_service_object,
        'list_func': list_service_objects        
      },
      {
        'name': 'sources', 
        'singular_label': 'datasource',
        'plural_label': 'datasources',
        'find_func': find_xfile_datasource_by_name,
        'create_func': create_xfile_datasource,
        'update_func': edit_xfile_datasource,
        'list_func': list_xfile_datasources
      },
      {
        'name': 'maps',
        'singular_label': 'map',
        'plural_label': 'maps',
        'find_func': find_xfile_map_by_name,
        'create_func': create_xfile_map,
        'update_func': edit_xfile_map,
        'list_func': list_xfile_maps
      } 
    ]
  },
  'ngst': {
    'description': 'Send CSV or JSON records to a designated target',
    'template': templates.NGST_TEMPLATE,
    'config_object_types': [
      {
        'name': 'globals',
        'singular_label': 'global',
        'find_func': find_global_by_name,
        'create_func': create_global,
        'update_func': edit_global,
        'list_func': list_globals
      },
      {
        'name': 'service_objects',
        'singular_label': 'service object',
        'find_func': find_service_object_by_name,
        'create_func': create_service_object,
        'update_func': edit_service_object,
        'list_func': list_service_objects        
      },
      {
        'name': 'datastores',
        'singular_label': 'ngst datastore',
        'find_func': find_ngst_datastore_by_name,
        'create_func': create_ngst_datastore,
        'update_func': edit_ngst_datastore,
        'list_func': list_ngst_datastores
      },
      {
        'name': 'ingest_targets',
        'singular_label': 'ingest target',
        'find_func': find_ngst_target_by_name,
        'create_func': create_ngst_target,
        'update_func': edit_ngst_target,
        'list_func': list_ngst_targets
      }
    ]
  },
  'cyclops': {
    'description': 'Run custom code in response to filesystem events',
    'template': templates.CYCLOPS_TEMPLATE,
    'config_object_types': [
      {
        'name': 'globals',
        'singular_label': 'global',
        'find_func': find_global_by_name,
        'create_func': create_global,
        'update_func': edit_global,
        'list_func': list_globals
      },
      {
        'name': 'service_objects',
        'singular_label': 'service object',
        'find_func': find_service_object_by_name,
        'create_func': create_service_object,
        'update_func': edit_service_object,
        'list_func': list_service_objects        
      },
      {
        'name': 'triggers',
        'singular_label': 'filesystem event trigger',
        'find_func': find_cyclops_trigger_by_name,
        'create_func': create_cyclops_trigger,
        'update_func': edit_cyclops_trigger,
        'list_func': list_cyclops_triggers
      }
    ]
  },
  'j2sqlgen': {
    'description': 'Generate CREATE TABLE sql statements from JSON metadata',
    'template': templates.J2SQLGEN_TEMPLATE,
    'config_object_types': [
      {
        'name': 'globals',
        'singular_label': 'global',
        'find_func': find_global_by_name,
        'create_func': create_global,
        'update_func': edit_global,
        'list_func': list_globals
      },
      {
        'name': 'defaults',
        'singular_label': 'SQL generation default',
        'find_func': find_j2sqlgen_default_by_name,
        'create_func': create_j2sqlgen_default,
        'update_func': edit_j2sqlgen_default,
        'list_func': list_j2sqlgen_defaults
      },
      {
        'name': 'tables',
        'singular_label': 'j2sql target table',
        'find_func': find_j2sqlgen_target_by_name,
        'create_func': create_j2sqlgen_target,
        'update_func': edit_j2sqlgen_target,
        'list_func': list_j2sqlgen_targets
      }
    ]
  },
  'pgexec': {
    'description': 'Execute SQL commands against a PostgreSQL database',
    'template': templates.PGEXEC_TEMPLATE,
    'config_object_types': [
        {
          'name': 'targets',
          'singular_label': 'target',
          'find_func': find_pgexec_target_by_name,
          'create_func': create_pgexec_target,
          'update_func': edit_pgexec_target,
          'list_func': list_pgexec_targets
        },
      ]
  },
  'pgmeta': {
    'description': 'Extract table metadata as JSON from a PostgreSQL database',
    'template': templates.PGMETA_TEMPLATE,
    'config_object_types': [
        {
          'name': 'targets',
          'singular_label': 'target',
          'find_func': find_pgexec_target_by_name, # pgmeta and pgexec use the same target
          'create_func': create_pgexec_target,
          'update_func': edit_pgexec_target,
          'list_func': list_pgexec_targets
        }
      ]
  },
  'profilr': {
    'description': 'Run custom data profiling logic against a file-based dataset',
    'template': templates.PROFILR_TEMPLATE,
    'config_object_types': [
        {
        'name': 'globals',
        'singular_label': 'global',
        'find_func': find_global_by_name,
        'create_func': create_global,
        'update_func': edit_global,
        'list_func': list_globals
      },
      {
        'name': 'service_objects',
        'singular_label': 'service object',
        'find_func': find_service_object_by_name,
        'create_func': create_service_object,
        'update_func': edit_service_object,
        'list_func': list_service_objects
      },
      {
        'name': 'profilers',
        'singular_label': 'profiler',
        'find_func': find_profiler_by_name,
        'create_func': create_profiler,
        'update_func': edit_profiler,
        'list_func': list_profilers
      },
      {
        'name': 'datasets',
        'singular_label': 'profilr dataset',
        'find_func': find_profilr_dataset_by_name,
        'create_func': create_profilr_dataset,
        'update_func': edit_profilr_dataset,
        'list_func': list_profilr_datasets
      }
    ]
  },
  'quasr': {
    'description': 'Run custom QA/profiling code against a relational dataset',
    'template': templates.QUASR_TEMPLATE,
    'config_object_types': [
      {
        'name': 'globals',
        'singular_label': 'global',
        'find_func': find_global_by_name,
        'create_func': create_global,
        'update_func': edit_global,
        'list_func': list_globals
      },
      {
          'name': 'service_objects',
          'singular_label': 'service object',
          'find_func': find_service_object_by_name,
          'create_func': create_service_object,
          'update_func': edit_service_object,
          'list_func': list_service_objects
      },
      {
          'name': 'templates',
          'singular_label': 'template',
          'find_func': find_quasr_template_by_name,
          'create_func': create_quasr_template,
          'update_func': edit_quasr_template,
          'list_func': list_quasr_templates
      },
      {
          'name': 'jobs',
          'singular_label': 'job',
          'find_func': find_quasr_job_by_name,
          'create_func': create_quasr_job,
          'update_func': edit_quasr_job,
          'list_func': list_quasr_jobs
      }
    ]
  }
}


def docopt_cmd(func):
    """
    This decorator is used to simplify the try/except block and pass the result
    of the docopt parsing to the called action.
    """
    def fn(self, arg):
        try:
            opt = docopt_func(fn.__doc__, arg)
            #opt = docopt_func(usage_string, arg)

        except DocoptExit as e:
            # The DocoptExit is thrown when the args do not match.
            # We print a message to the user and the usage block.

            print('\nPlease specify one or more valid command parameters.')
            print(e)
            return

        except SystemExit:
            # The SystemExit exception prints the usage for --help
            # We do not need to do the print here.
            return

        return func(self, opt)

    fn.__name__ = func.__name__
    fn.__doc__ = func.__doc__
    fn.__dict__.update(func.__dict__)
    return fn


def docstring(docstr, sep="\n"):
    """
    Decorator: Append to a function's docstring.
    """
    def _decorator(func):
        if func.__doc__ == None:
            func.__doc__ = docstr
        else:
            func.__doc__ = sep.join([func.__doc__, docstr])
        return func
    return _decorator


class ConfigCLI(Cmd):
    def __init__(self,
                 name,
                 target_name,
                 target_package,
                 **kwargs):

        Cmd.__init__(self)
        self.name = name
        self.prompt = '__%s [%s]> ' % (self.name, target_name)
        self.target_package = target_package
        self.configuration = {}
        #self.replay_stack = Stack()

    def find_config_package_by_plural_label(self, label):
      for config_object_type in self.target_package['config_object_types']:
        if config_object_type['plural_label'] == label:
          return config_object_type


    def find_config_package_by_singular_label(self, label):
      for config_object_type in self.target_package['config_object_types']:
        if config_object_type['singular_label'] == label:
          return config_object_type
      

    def config_object_singular_labels(self):
      return [conftype['singular_label'] for conftype in self.target_package['config_object_types']]


    def config_object_plural_labels(self):
      return [conftype['plural_label'] for conftype in self.target_package['config_object_types']]


    def usage_string_for_new(self):
      template = '''Usage:
          new ({options})
      '''
      return template.format(options=' | '.join(self.config_object_singular_labels()))
    

    def usage_string_for_find(self):
      template = '''Usage:
          find ({options})
      '''      
      return template.format(options=' | '.join(self.config_object_singular_labels()))


    def usage_string_for_list(self):
      template = '''Usage:
          list ({options})
      '''
      return template.format(options=' | '.join(self.config_object_plural_labels()))


    def get_selected_option(self, arg_dict, option_list):
      for item in option_list:
        if arg_dict.get(item) == True:
          return item
      return None


    @contextmanager
    def docopt_parse(self, usage_string, *cmd_args):
      try:
        args = docopt.docopt(usage_string, *cmd_args)
        yield args, None            

      except DocoptExit as e:
        # The DocoptExit is thrown when the args do not match.
        # We print a message to the user and the usage block.

        error_msg = '\nPlease specify one or more valid command parameters.\n%s\n' % e
        yield None, error_msg

      except SystemExit:
        # The SystemExit exception prints the usage for --help
        # We do not need to do the print here.
        raise


    def do_list(self, *cmd_args):
      with self.docopt_parse(self.usage_string_for_list(), *cmd_args) as (args, error):
        if not error:
          selection = self.get_selected_option(args, self.config_object_plural_labels())
          pkg = self.find_config_package_by_plural_label(selection)
          if not pkg:
            print('!!! ERROR: No configuration package found with label "%s".' % selection)

          list_function = pkg['list_func']
          if not self.configuration.get(pkg['name']):
            self.configuration[pkg['name']] = []
          objects_to_list = self.configuration[pkg['name']]
          list_function(objects_to_list)
        else:
          print(error)


    def do_new(self, *cmd_args):            
      with self.docopt_parse(self.usage_string_for_new(), *cmd_args) as (args, error):
        if not error:
          
          selection = self.get_selected_option(args, self.config_object_singular_labels())
          #print('you selected %s.' % selection)
          pkg = self.find_config_package_by_singular_label(selection)
          if not pkg:
            print('!!! ERROR: No configuration package found with label "%s".' % selection)

          config_object = pkg['create_func']()

          if not self.configuration.get(pkg['name']):
            self.configuration[pkg['name']] = []

          self.configuration[pkg['name']].append(config_object)

        else:
          print(error)


    def do_quit(self, *cmd_args):
        print('%s CLI exiting.' % self.name)        
        raise SystemExit

    do_q = do_quit


def main(args):
    if args['--list-targets']:
      print(BANNER)
      for name, target in targets.items():
        print('|: %s (%s)' % (name, target['description']))
        print('|:')      
      print(BANNER_CLOSE)
      return

    config_target_name = args['<target>']
    target_pkg = targets.get(config_target_name)
    if not target_pkg:
      print('Unsupported configuration target: %s' % config_target_name)
      return

    config_cli = ConfigCLI('mkcfg', config_target_name, target_pkg)
    config_cli.cmdloop()

if __name__ == '__main__':
    args = docopt.docopt(__doc__)
    main(args)