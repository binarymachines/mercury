#!/usr/bin/env python

'''
Usage:
    quasr --config <configfile> --job <jobname> [--params=<n:v>...]
    quasr --config <configfile> --jobs
'''

# QUASR: Quality Assurance SQL Runner

import os, sys
import re
import docopt
from collections import namedtuple
from snap import snap, common


PARAM_DELIMITER = ':'
PARAM_TOKEN_DELIMITER = ','

integer_rx = re.compile(r'^[0-9]+$')
float_rx = re.compile(r'^[0-9]*.[0-9]+$')
string_rx = re.compile(r'^[a-zA-Z0-9_]+$')


TypeFormat = namedtuple('TypeFormat', 'class_object regex')

type_formats = {
    'str': TypeFormat(class_object=str, regex=string_rx),
    'float': TypeFormat(class_object=float, regex=float_rx),
    'int': TypeFormat(class_object=int, regex=integer_rx)
}

Slot = namedtuple('Slot', 'name datatype')

class QaSqlNode(object):
    def __init__(self, query_template):
        self.sql_template = query_template
        self.input_slots = {}
        self.output_slots = {}


    def add_input_slot(self, name, classname):
        self.input_slots[name] = Slot(name, classname)


    def add_output_slot(self, name, classname):
        self.output_slots[name] = Slot(name, classname)


    def validate_input_types(self, **kwargs):
        for name, value in kwargs.items():
            input_slot = self.input_slots.get(name)
            if not input_slot:
                raise Exception('No input slot "%s" registered with this QA node.')

            if value.__class__.__name__ != input_slot.datatype:
                raise Exception('The input parameter "%s" does not match the registered slot type "%s".' 
                                % (name, input_slot.datatype))


    def generate_query(self, **kwargs):
        kwreader = common.KeywordArgReader(*self.input_slots.keys())
        kwreader.read(**kwargs)
        self.validate_input_types(**kwargs)
        return self.sql_template.format(**kwargs)


class QaJobRunner(object):
    def __init__(self, yaml_config):
        self.qa_nodes = {}
        self.config = yaml_config
        self.service_registry = common.ServiceObjectRegistry(snap.initialize_services(yaml_config))
        
        job_config_group = yaml_config['jobs']
        for nodename in job_config_group:
            template = self._load_template(job_config_group[nodename]['sql_template'])
            inputs =  self._load_input_values(job_config_group[nodename]['inputs'])
            outputs = self._load_output_values(job_config_group[nodename]['outputs'])
            node = QaSqlNode(template)

            for input in inputs:                
                node.add_input_slot(input['name'], input['type'])

            for output in outputs:                
                node.add_output_slot(output['name'], output['type'])

            self.qa_nodes[nodename] = node


    def _load_input_values(self, dict_array):
        input_values = []
        for input in dict_array:
            input_values.append({'name': input['name'], 'type': input['type']})
        return input_values


    def _load_output_values(self, dict_array):
        output_values = []
        for output in dict_array:
             output_values.append({'name': output['name'], 'type': output['type']})
        return output_values


    def _load_template(self, template_name):
        # this is not really loading a class -- the underlying logic just pulls the named
        # attribute of the loaded Python module using getattr(). 
        # TODO: create a load_module_object() method, so as not to mislead
        return common.load_class(template_name, self.config['globals']['template_module'])
    

    def _lookup_node(self, job_name):
        node = self.qa_nodes.get(job_name)
        if not node:
            raise Exception('no job registered under alias "%s".' % job_name)
        return node


    def get_sql_template(self, job_name):
        node = self._lookup_node(job_name)        
        return node.sql_template


    def inputs(self, job_name):
        node = self._lookup_node(job_name)
        result = {}
        for name, slot in node.input_slots.items():
            result[name] = slot.datatype
        return result


    def convert_input_params(self, job_name, **kwargs):
        node = self._lookup_node(job_name)
        job_params = {}
        slots = node.input_slots
        for param_name, param in kwargs.items():
            input_slot = slots.get(param_name)
            if not input_slot:
                raise Exception('no input slot registered with name "%s".' % param_name)
            
            type_format = type_formats.get(input_slot.datatype)
            if not type_format:
                raise Exception('input datatype "%s" is not supported.' % input_slot.datatype)
            
            if not type_format.regex.match(param):
                raise Exception('the format of input param "%s" (value: "%s") does not match type %s.'
                                % (param_name, param, input_slot.datatype))

            job_params[param_name] = type_format.class_object(param)

        return job_params

    def run(self, job_name, preview_mode=False, **kwargs):
        # execute query -- must return record generator
        # call job node's generate_outputs() method and pass in generator
        # if there is an analyzer attached to this job, pass it the outputs
        # return the raw and analyzed outputs
        node = self._lookup_node(job_name)
        query = node.generate_query(**kwargs)
        if preview_mode:
            print(query)
        else:
            job_config_group = self.config['jobs']
            exec_func_name = job_config_group[job_name]['executor_function']
            output_builder_func_name = job_config_group[job_name]['builder_function']
            # this is not a class being loaded, but a pythonic generator function
            query_executor = common.load_class(exec_func_name,  self.config['globals']['qa_logic_module'])

            # load the function which builds outputs from the query results
            output_builder_func = common.load_class(output_builder_func_name, self.config['globals']['qa_logic_module'])
            raw_outputs =  output_builder_func(query_executor(query, self.service_registry, **kwargs))
            return raw_outputs


def read_params_from_args(arg_dict):
    params = {}
    if not arg_dict.get('--params'):
        return params

    param_string = args['--params'][0]
    param_tokens = [pstring.lstrip().rstrip() for pstring in param_string.split(PARAM_TOKEN_DELIMITER)]
    for token in param_tokens:
        if PARAM_DELIMITER not in token:
            raise Exception('the optional --params string must be in the form of name1:value1,...nameN:valueN')
        name = token.split(PARAM_DELIMITER)[0].lstrip().rstrip()
        value = token.split(PARAM_DELIMITER)[1].lstrip().rstrip()
        params[name] = value
    return params


def main(args):
    configfile = args['<configfile>']
    yaml_config = common.read_config_file(configfile)

    if args['--jobs']:
        jobs = []
        for job in yaml_config['jobs']:
            input_params = yaml_config['jobs'][job]['inputs']
            output_params = yaml_config['jobs'][job]['outputs']
            jobs.append({
                'name': job,
                'inputs': input_params,
                'outputs': output_params
            })
        print(common.jsonpretty(jobs))
        return

    job_runner = QaJobRunner(yaml_config)

    if args['--job']:
        jobname = args['<jobname>']
        print(job_runner.get_sql_template(jobname))
        print(job_runner.inputs(jobname))
        input_params = read_params_from_args(args)

        job_params = job_runner.convert_input_params(jobname, **input_params)
        print(job_runner.run(jobname, **job_params))
        return


if __name__ == '__main__':
    args = docopt.docopt(__doc__)
    main(args)

